/*
 * author: visodo-AM
 * This video sources receives images from a ROS image topic
 *
 * General mode of operation:
 * In order to communicate with ROS, we need to create a ROS node that is compiled via rosmake
 * to a shared library.
 * The library provides functions we can call from within this class. So, first, we need to import
 * those functions from the shared library and create wrapper functions.
 *
 * Subsequently, ros_init is called and we subscribe to the image and imu topics.
 * Whenever a new image is requested via the GetAndFillFrame method, we trigger a ros::spin
 * and wait for the callback.
 */

#include <string.h>
#include <glib.h>
#include "VideoSource.h"

//#include <cvd/Linux/v4lbuffer.h>
#include <cvd/colourspace_convert.h>
#include <cvd/colourspaces.h>
#include <gvars3/instances.h>

#include <stdio.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>

using namespace CVD;
using namespace std;
using namespace GVars3;

static const int GST_MAX_WIDTH = 640;
static const int GST_MAX_HEIGHT = 480;
//static const int GST_MAX_WIDTH = 1920;
//static const int GST_MAX_HEIGHT = 1080;

static double mFrameNumber;
static ImageRef mFrameSize(GST_MAX_WIDTH, GST_MAX_HEIGHT);

// Typedefs for the function pointers in order to cast them from the dlsym call
typedef void (*RosInit_ptr)();
typedef void (*RosSpinOnce_ptr)();
typedef void (*RosSubscribe_ptr)(void(*callback)(Image<Rgb<byte> >, Image<byte>,
    vector<double>, vector<double>, vector<double>, int32_t, int32_t, int32_t));

// Variables for the functions to be called
RosInit_ptr rosInit;
RosSpinOnce_ptr rosSpinOnce;
RosSubscribe_ptr rosSubscribe;

char* error;
void* handle;

bool callbackReturned; // notification switch when callback has been called

// local member variables to store data from the callback, in order to return it in the
// FillFrame method
Image<Rgb<byte> > mImRGB; // color frame
Image<byte> mImBW; // black and white frame
vector<double> mvOrientation;
vector<double> mvVelocity;
vector<double> mvAcceleration;
int32_t mSec; //timestamp
int32_t mNsec;
int32_t mSeq;

/*
 * This callback is called after a ROS message has been received
 */
void RosCallback(Image<Rgb<byte> > imRGB, Image<byte> imBW,
    vector<double> orientation, vector<double> angular_velocity, vector<double> linear_acceleration,
    int32_t sec, int32_t nsec, int32_t seq)
{
  cout << "start of callback" << endl;
  // copy images from callback to member variables
  mImRGB = imRGB;
  mImBW = imBW;
  mvOrientation = orientation;
  mvVelocity = angular_velocity;
  mvAcceleration = linear_acceleration;

  mSec = sec;
  mNsec = nsec;
  mSeq=seq;

  // notify GetAndFillFrame method that the callback arrived and the images are ready
  cout << "1) sec: " << sec << " nsec: " << nsec << endl;
  callbackReturned = true;
  cout << "end of callback" << endl;
}

/*!
 * Default constructor for the VideoSource class.
 */
VideoSource::VideoSource() {

  handle = dlopen("lib/libptam_ros_wrapper.so", RTLD_LAZY);
  if (!handle) {
    fputs(dlerror(), stderr);
    exit(1);
  }

  // Get the function handles

  /*
   * rosInit has to be called at the beginning
   */
  rosInit = (RosInit_ptr) dlsym(handle, "ros_init");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }

  /*
   * rosSpinOnce has to be called regularly to trigger callbacks
   */
  rosSpinOnce = (RosSpinOnce_ptr) dlsym(handle, "ros_spinOnce");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }

  /*
   * rosSubscribe serves for subscribing to ROS topics. The function expects
   * a callback function as argument. This callback function is then called
   * whenever a ROS event arrives. In our case, these are camera images and IMU data.
   */
  rosSubscribe = (RosSubscribe_ptr) dlsym(handle, "ros_subscribe");
  if ((error = dlerror()) != NULL) {
    fputs(error, stderr);
    exit(1);
  }

  // do ROS init and subscribe to callback
  rosInit();
  rosSubscribe(RosCallback);

  mFrameNumber = 0;
}

/*!
 * Destructructor for the VideoSource class.
 */
VideoSource::~VideoSource() {

  dlclose(handle);
}

/*!
 * Returns the size of the video frames generated by the video decode pipeline,
 * as specified in the GST_MAX_WIDTH and GST_MAX_HEIGHT constants.
 *
 * @return ImageRef object containing the width and height in the x and y member
 * functions.
 */
ImageRef VideoSource::Size() {
  return mFrameSize;
}

/*!
 * Retrieves the next ROS image.
 *
 * @param imBW  Return parameter containing the current video frame decoded in monochrome.
 * @param imRGB Return parameter containing the current video frame decoded in RGB.
 */
void VideoSource::GetAndFillFrameBWandRGB(Image<byte> &imBW, Image<Rgb<byte> > &imRGB,
    vector<double> &vOrientation, vector<double> &vVelocity, vector<double> &vAcceleration,
    int32_t &sec, int32_t &nsec, int32_t& seq) {

  // trigger and wait for callback
  callbackReturned = false;
  rosSpinOnce();
  //	while (true) {
  //		//usleep(10);
  //		sleep(1);
  //		cout << "waiting..." << endl;
  //		if (callbackReturned) break;
  //	}

  if (mImRGB.totalsize() > 0) // there was an image
  {
    //cout << "2) mSec: " << sec << " mNsec: " << nsec << endl;
    imRGB.copy_from(mImRGB);
    imBW.copy_from(mImBW);
    vOrientation = mvOrientation;
    vVelocity = mvVelocity;
    vAcceleration = mvAcceleration;
    sec = mSec;
    nsec = mNsec;
    seq = mSeq;
    mFrameNumber++;
  } else {
//    cerr << "there was no image" << endl; // happens only at the beginning
    vOrientation =  vector<double>(3,0.0);
    vVelocity =  vector<double>(3,0.0);
    vAcceleration = vector<double>(3,0.0);
    sec = 0;
    nsec = 0;
    seq = -1;
    usleep(500);
  }

}
